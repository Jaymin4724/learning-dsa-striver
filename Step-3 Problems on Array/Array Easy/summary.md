| **#** | **Algorithm**                                                     | **Approach / Explanation**                                                                                                                                                                                                                                                                                              | TC       | **SC** |
| ----------- | ----------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- | ------------ |
| (1)         | Largest Element in an Array                                             |                                                                                                                                                                                                                                                                                                                               | O(n)     |              |
| (2)         | Second Largest Element in an Array                                      |                                                                                                                                                                                                                                                                                                                               | O(n)     |              |
| (3)         | Check Whether the Array is Sorted or Not                                | Nested Loop Traversal:                                                                                                                                                                                                                                                                                                        | O(n²)   |              |
|             |                                                                         | Single Traversal Logic:                                                                                                                                                                                                                                                                                                       | O(n)     |              |
| (4)         | Remove Duplicates from a Sorted Array                                   | Using Sets                                                                                                                                                                                                                                                                                                                    | O(n)     | O(n)         |
|             |                                                                         | Two Pointer Approach<br />(i --> represents the position of the last <br />unique element found so far, <br />j --> traverses the array and finds <br />the unique element)                                                                                                                                                   | O(n)     | O(1)         |
| (5)         | Left/Right Rotate the Array by One Place                                |                                                                                                                                                                                                                                                                                                                               | O(n)     | O(1)         |
| (6)         | Left/Right Rotate the Array by<br />'d' Places(rotations d = d % n)     | Approach 1:- Take the first d elements in a vector<br />- Arrange the rest of the elements at the <br />start of the array<br />- Place the vector elements immediately <br />after arranging the rest elements                                                                                                               | O(n)     | O(d)         |
|             |                                                                         | Approach 2 (Recursive Approach):                                                                                                                                                                                                                                                                                              | O(n)     | O(1)         |
| (7)         | Move the Zeroes to the End of the Array                                 | Two Pointer Approach:<br />(i --> determines the correct <br />position of non-zero element<br />j --> traverses the array and finds the <br />non-zero elementand in the last <br />adds the rest of the elements with value 0)                                                                                              | O(n)     | O(1)         |
| (8)         | Linear Search                                                           |                                                                                                                                                                                                                                                                                                                               | O(n)     | O(1)         |
| (9)         | Union/Intersection of Two Sorted Arrays                                 | Two Pointer Approach                                                                                                                                                                                                                                                                                                          | O(n + m) | O(1)         |
| (10)        | Find the Missing Number                                                 | Bruteforce                                                                                                                                                                                                                                                                                                                    | O(n²)   |              |
|             |                                                                         | Better Approach (Hashing)                                                                                                                                                                                                                                                                                                     | O(n)     |              |
|             |                                                                         | Better Best Approach (Sum Formula)                                                                                                                                                                                                                                                                                            | O(n)     |              |
|             |                                                                         | Best Approach (XOR Operation)                                                                                                                                                                                                                                                                                                 | O(n)     |              |
| (11)        | Find the Max Consecutive Ones                                           |                                                                                                                                                                                                                                                                                                                               | O(n)     | O(1)         |
| (12)        | Find the Numbers That Appear Once<br />While Other Numbers Appear Twice | Bruteforce (Nested For-Loops)                                                                                                                                                                                                                                                                                                 | O(n²)   |              |
|             |                                                                         | Better Option (Hashing)                                                                                                                                                                                                                                                                                                       | O(n)     |              |
|             |                                                                         | Best Option (XOR Operation)                                                                                                                                                                                                                                                                                                   |          |              |
| (13)        | Find the Longest Subarray<br />Whose Sum is Exactly K                   | Brute Force Approach (Three Nested Loops)<br />- Loop through all subarrays with <br />three nested loops <br />- Calculate sum of each subarray <br />- Check if sum equals K and update maxLen                                                                                                                              | O(n³)   | O(1)         |
|             |                                                                         | Better Brute Force Approach (Using Running Sum)<br />- Loop with two nested loops <br />- Maintain a running sum instead of recomputing it <br />- If sum equals K, update maxLen                                                                                                                                             | O(n²)   | O(1)         |
|             |                                                                         | Two Pointer / Sliding Window Approach<br />- Use two pointers to maintain a window <br />- Move pointers based on comparison of <br />current sum with K <br />✅ Works only for non-negative elements                                                                                                                        | O(n)     | O(1)         |
|             |                                                                         | Optimal Approach using Hash Map + Prefix Sum<br />- Maintain a running sum (prefixSum)<br />- If prefixSum equals K, update maxLen <br />- If (prefixSum - K) exists in hash map, <br />update maxLen as i - prefixMap\[prefixSum - K]<br />- Store the first occurrence of each prefixSum <br />to maximize future subarrays | O(n)     | O(n)         |
